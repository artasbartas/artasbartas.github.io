{"name":"How to turn Wordpress into a a mobile backend","tagline":"Step-by-step guide to powering a mobile app","body":"## Introduction\r\nWhen it comes to publishing on the web, few platforms come close to Wordpress: it has a friendly user interface, vibrant developer community, and a large marketplace of custom themes, plugins, and professional services. However, very few people to date have taken the advantage of the Wordpress CMS to power mobile apps. Here are the immediate benefits such a setup would yield:   \r\n\r\n1. *Faster development cycle*. Rather than building an API from the scratch, take an advantage of the functionality afforded by Wordpress and significantly reduce the development budget.\r\n2. *Beautiful editing interface*. Wordpress was developed with authors in mind, which makes it a perfect tool for composing entries for mobile apps.\r\n3. *Re-usable content*. Using Wordpress for website and mobile content eliminates duplicate work, since the same entries are consumed by web and mobile clients. \r\n4. *Real-time publishing*. With plugins like WP API, new content is available within a mobile app immediately after it is published.\r\n\r\nAre you convinced already? Great! This tutorial contains detailed steps for turning a Wordpress instance into a mobile CMS for managing the content of the iOS and Android apps. To reference more technical points of the tutorial, we shall use the [Canopy app][1] for iOS. Canopy features a curated list of cool gifts sold on Amazon and, importantly for us, has a straightforward structure making it easy to follow.\r\n\r\n### Table of Contents\r\n- Initial requirements\r\n- Installation\r\n- Authentication\r\n- Working with the API\r\n- Defining content structure \r\n- Extending the API\r\n- Parting thoughts\r\n- Further reading\r\n\r\n### Initial requirements\r\nTo successfully complete this tutorial you will need the following credentials, tools and plugins:\r\n- A hosted server with MySQL database\r\n- FTP credentials\r\n- An FTP client ([Cyberduck][2], [Filezilla][3], [Transmit][4], etc.)\r\n- [Advanced Custom Fields (ACF)][5] and [WP API][6] plugins\r\n- [WP OAuth Server][7] and [Basic Auth][8] plugins \r\n\r\n## Installation\r\nDownload the latest version of Wordpress from https://wordpress.org/download/ and extract the contents of the ZIP archive. You could then follow the famous 5 minute install to get your instance of Wordpress up and running.\r\n\r\n**NB.** Before you start, make sure that your hosting provider includes a MySQL database in the package you booked. \r\n\r\nThe next step is to install plugins. In the menu on the left, navigate to **Plugins > Add New**. In the **Add Plugin** screen, use the search bar to find a plugin and click **Install**. Once a plugin installed, activate it and you should see new menu items on the left.\r\n\r\nWe are interested in three plugins specifically. [Advanced Custom Fields][5] allows you to add custom fields to Wordpress. This will become important once we get to modeling the content structure of the mobile app. \r\n\r\n[WP API][6] exposes the website data through an intuitive REST API enabling mobile apps to communicate with your CMS. It will be included in the core of the Wordpress starting with the version 4.1, but for now you have to install it manually. \r\n\r\nFinally, the [OAuth Server][7] plugin is required to authenticate your client for the use with WP API. \r\n\r\n### Authentication\r\nBefore we go any further, we need to authenticate ourselves. Wordpress supports three types of [authentication][9]:\r\n\r\n- *Cookie authentication*. Sets up a cookie once a user logs into a dashboard. The method is mostly used for authenticating Wordpress plugins and themes.\r\n\r\n- *Basic authentication*. This method only requires a username and password. The client takes these two credentials and uses base64 encoding to transform them into a single string, e.g. `bG9naW46cGFzc3dvcmQ=` that gets passed to a server. This method requires the Basic Auth plugin to be installed.\r\n\r\n- *OAuth authentication*. is the designated authentication method for external clients on mobile, web and desktop. Each client is issued with a unique token granting it access to API resources. This method requires OAuth server plugin to be installed on your Wordpress server.\r\n\r\nWorking with the OAuth method requires completing three steps: registering the client (in our case, a mobile app) with the OAuth server, authenticating the client, and obtaining an access token to be used for issuing routine API calls. \r\n\r\nFor the first step, head over to OAuth Server plugin settings and add a new client.\r\n[OAuth first step](http://i.imgur.com/wBnnV5p.png)\r\n\r\nAfter this you can click on the Clients Tab to view the generated Client ID:\r\n[Oauth second step](http://i.imgur.com/BijldaA.png)\r\n\r\nPlease note that the older version of the WP OAuth Server plugin required you to use the CLI to generate client key and secret. The tutorial, references the latest version of the plugin (3.1.5), which allows you to perform these steps within the Wordpress admin interface.\r\n\r\n    curl https://mysite.com/authorize?client_id=xxxxx&redirect_uri=https://mysite.com/redirect-uri/&response_type=token\r\n\r\nNote that response type can be “token” or “code”. “Token” value should be used for client-side applications, where confidentiality of secrets cannot be guaranteed; “code” is used for server-side applications. \r\n\r\nSince we are working with the mobile app, we chose to indicate response type as “token”. This will result in a callback giving us the access token:\r\n\r\n\tcurl http://mysite.com/#access_token=xxxxx&expires_in=86400&token_type=Bearer&scope=basic\r\n\r\nIf you would like to generate an access token for use on the server-side, the process includes an extra step. Following the authentication call, the OAuth server will respond with the Redirect URI along with a GET parameter containing the authorization code:  \r\n\r\n\thttps://mysite.com/redirect-uri/cb?code=xxx\r\n\r\nYou now have to combine your client ID, client secret and this code to make a POST call to the access token endpoint:\r\n\r\n\tcurl -u client_id:client_secret http://server.com/oauth/token -d ‘grant_type=authorization_code&code=xxx’\r\n\r\nAt this point, you should have an access token, which will enable you to create, update and delete posts and other entities via WP API plugin. All you need to do is to attach the access token to your API call as indicated below:\r\n\r\n\thttps://mysite.com/wp-json/posts/34/revisions?access_token=xxxxx\r\n\r\n## Working with the API\r\nNow let’s look at how your mobile app uses API to communicate with the Wordpress website. API, or an application programming interface, is a set of rules specifying how a server communicates with a client. The proper discussion of API architecture is beyond the scope of this article, but to keep you grounded let’s briefly look at the key concepts. \r\n\r\nModern APIs are built on top of the HTTP protocol, which consists of requests and responses. Each requests consists of four elements: URL, method, headers and body. And each response includes a status code, headers, and body. Let’s look at these building blocks one by one.\r\n\r\n[API communication structure](http://i.imgur.com/r1J8h11.png)\r\n\r\n*URL*\r\nURL is a unique address for a specific resource. URLs can point to web pages, images or videos. In the context of WP API, you will have URLs pointing to posts, pages, authors, taxonomies and other entities. \r\n\r\n\thttp://mysite.com/wp-json/wp/v2/posts\t\r\n\r\n*Method*\r\nThe request method tells the server what kind of action the client wants the server to perform. The REST API has four methods: \r\n\r\n- \tGET: retrieves information from the server \r\n- \tPOST: sends new information to the server\r\n- \tPUT: updates existing information on the server\r\n- \tDELETE: removes existing information from the server\r\n\r\nThus, whenever a client wants to fetch data from the website, it has to issue a GET request; to create a new entry, it will send a POST request and so on.\r\n\r\n*Headers* \r\nHeaders provide meta-information about a request. They usually include things like time of the request, type of a device sending a request (*user-agent*), in what format data should be provided (*content-type*) and tokens authorizing a client to fetch server resources (*authentication*).\r\n\r\n\tDate: Fri, 13 Aug 2015 03:35:14 GMT\r\n\tLast-Modified: Fri, 13 Aug 2015 03:35:14 GMT\r\n\tConnection: Keep-Alive\t \r\n\tPragma: no-cache\r\n\tServer: Apache\r\n\tTransfer-Encoding: chunked\r\n\tX-Content-Type-Options: nosniff\r\n\tContent-Type: application/json; charset=UTF-8\r\n\r\nA word about data formats. If you look at the last line of the headers example you will see `application/json` tag specifying that the response body is encoded in JSON format. The two most common formats found in modern APIs are JSON (JavaScript Object Notation) and XML (Extensible Markup Language). Important thing to know here is that they are both formats for encoding data in a structured way, though they employ different syntax for that purpose. \r\n\r\nJSON format has two pieces: *keys* and *values*. A key represents an attribute of a described object (e.g. name, phone number) and a value provides an actual value (e.g. “John”, “123-500-4000”). By contrast, XML is organized in nodes, with root node at the top level and child nodes lower in the hierarchy. Each node specifies an attribute of an object and the data inside the node is an actual value.\r\n\r\n\tExample : KEY1 | VALUE OBJECT1 - (NAME: \"JOHN\", VALUE:123-500-4000) \r\n\r\nFor Example, A Cake order could be an object. It has attributes (keys), such as base type, toppings, order status etc. These attributes have corresponding values chocolate-base, vanilla, and out-for-delivery.\r\nIn JSON it would appear as :\r\n    \r\n    {\r\n        \"base\": \"chocolate-base\",\r\n        \"toppings\": [\"vanilla\"],\r\n        \"status\": \"ready\"\r\n    }\r\n\r\nWhen you want to use an object as the value for a key you can extend the cake order details with customer details:\r\n\r\n    {\r\n      \"base\": \"chocolate-base\",\r\n      \"toppings\": [\"vanilla\"],\r\n      \"status\": \"ready\",\r\n      \"customer\": {\r\n        \"name\": \"Alex\",\r\n        \"phone\": \"999-000-1661\"\r\n      }\r\n    }         \r\n\r\n*Body*\r\nBody is the part of a request or response where actual data resides. Body part is not restricted by specific protocols, so client can put all kinds of things in here - from a new post to a batch of photos. An HTTP response will include a body with the actual entry data that you will want to display within the mobile client.\r\n\r\n\t{\r\n\t\t“title”: “Hello World”,\r\n\t\t“content”: “Hello. I am a test post. I was created by the API”,\r\n\t\t“tags”: [“tests”, “body”, “example”],\r\n\t\t“categories”: “API”\r\n\t}\r\n\r\n*Status*\r\nStatus codes are three-digit numbers with unique meanings you find in HTTP responses. For example, status 200 signals that a request was successful, while 503 indicates that the server is currently done. Status help you to get to the bottom of the problem when things go wrong, because they often contain information explaining the nature of the error. One status code to pay special attention to is 404, which means a resource was not found. As you go through building out a mobile backend, you  are likely to encounter it more than once. \r\n\r\n### Tools\r\nOne more thing to keep in mind before we start. If you are just getting to grips with APIs, you might want to consider installing the [Postman][10] or [Dev HTTP Client][11] plugin (both only available for Chrome at the moment). The plugins take a lot of hassle out of working with APIs, since they come with smart defaults, transform entered variables into syntactically correct API calls and display nicely formatted responses. \r\n\r\nHere’s a snapshot of the Postman tool:\r\n[Postman REST API plugin](http://i.imgur.com/W0s4gWK.jpg)\r\n\r\nFor those of you using a terminal to run API queries, you will notice that WP API responses are sometimes hard to read due to poor formatting. This issue can be easily corrected by installing the [jq utility][12] on your machine. jq is a library for processing JSON objects and among the many things it does, it can also produce nicely formatted JSON responses.To install jq, run:\r\n\tbrew install jq\r\n\r\nNow add the option ‘| jq ‘.’’ at the end of your call and you get a nicely formatted API response.\r\n\tcurl http://mysite.com/wp-json/wp/v2/posts/1 | jq ‘.’ \r\n\r\n\\*\\*\\*\r\n\r\nWith the basics covered, we can now finally ready to take WP API for a spin. In your terminal (or plugin window) type the command to fetch all the posts from your Wordpress website: \r\n\tcurl http://mysite.com/wp-json/wp/v2/posts\r\n\r\nThe response should look similar to this:\r\n`[`\r\n`{`\r\n`\"id\":26,`\r\n`\"date\":\"2015-08-06T08:50:45\",`\r\n`\"guid\":{\"rendered\":\"http:\\/\\/mysite.com\\/?p=26\"},`\r\n`\"modified\":\"2015-08-06T08:50:45\",`\r\n`\"modified_gmt\":\"2015-08-06T08:50:45\",`\r\n`\"slug\":\"my-slug\",`\r\n`\"type\":\"post\",`\r\n`\"link\":\"http:\\/\\/mysite.flinkly.com\\/wp-api\\/post1\",`\r\n`\"title\":{\"rendered\":\"Title name\"},`\r\n`\"content\":{\"rendered\":\"<p># Description<\\/p>\\n<p>A long descriptive text<\\/p>\\n\"},`\r\n`\"author\":1,`\r\n`\"featured_image\":0,`\r\n`\"comment_status\":\"open\",`\r\n`\"ping_status\":\"open\",`\r\n`\"sticky\":false,`\r\n`\"format\":\"standard\",`\r\n`\"_links\":`\r\n`{`\r\n`\"self\":`\r\n`[{\"href\":\"http:\\/\\/mysite.flinkly.com\\/wp-json\\/wp\\/v2\\/posts\\/26\"}],`\r\n`\"collection\":[{\"href\":\"http:\\/\\/wp.flinkly.com\\/wp-json\\/wp\\/v2\\/posts\"}],`\r\n`\"author\":[{\"embeddable\":true,\"href\":\"http:\\/\\/wp.flinkly.com\\/wp-json\\/wp\\/v2\\/users\\/1\"}],`\r\n`\"replies\":[{\"embeddable\":true,`\r\n`\"href\":\"http:\\/\\/mysite.flinkly.com\\/wp-json\\/wp\\/v2\\/comments?post_id=26\"}],`\r\n`\"version-history\":[{\"href\":\"http:\\/\\/mysite.com\\/wp-json\\/wp\\/v2\\/posts\\/26\\/revisions\"}]....`\r\n\r\nTo view the data from a single post, you can send a GET request to the post itself:\r\n\tcurl http://mysite.com/wp-json/wp/v2/posts/1\r\n\r\nDeleting a post, requires the client to provide the access token, but otherwise follows the familiar pattern:\r\n\r\n\tcurl -X DELETE http://mysite.com/wp-json/wp/v2/posts/4?access_token=xxxxx\r\n\r\nFor creating a post, let’s first create a simple JSON file with some dummy data and call it first-post.json:\r\n    {\r\n        “title”: “My first API post”,\r\n        “content_raw”: “Once upon a time, there was a HTTP request…”,\r\n\t    \t    “name”: “my-first-api-post”\r\n\t\t    “category”: “Tutorials”,\r\n\t\t    “comment_status”: “open”,\r\n\t\t    “tags”: [“biography”,”computers”,”api”]\r\n    }\r\n\r\nNow add this entry to the post collection:\r\n\tcurl -X POST http://mysite.com/wp-json/wp/v2/posts?access_token=xxxxx --data @first-post.json https://mysite.com/authorize?client_id=LJkqIAmqUIdEssIRalbS1kUV2QX0nz&redirect_uri=https://mysite.com/redirect/redirect-uri&response_type=token\r\n\r\nIf you follow the steps correctly, you should receive a 201 status indicating that the post has been created:\r\n\t<example>\r\n\r\nCongratulations, you are now ready to interact with all the default Wordpress entities, including users, media and comments,  through an API. At the very least, that should enable you to build a blogging mobile app. But what do you do if you want to go beyond blogging? That is the topic of our next section.\r\n\r\n## Content modeling\r\nLet’s go back to the original purpose of our tutorial, namely, building a simple, curated shopping app inspired by [Canopy][1].  To manage the app from Wordpress, we have to modify the default content model to accommodate the data that our app will require. A quick look at the Canopy app reveals that it works with three major content types:\r\n\r\n- *products* contain all the information about the merchandise, including the price, images, tags, relevant categories and external URL. The content type references user comments. \r\n- *users* hold user bio, collections, comments and whom she follows on the platform. The content type also reference the products a user has liked.\r\n- *brands* describe the brand and contain a brand logo, URL, short description and reference the relevant products.\r\n\r\nThe illustration below provides a more detailed deconstruction of the content types. \r\n![Canopy app product page](http://i.imgur.com/qUUQ0Uk.jpg)\r\n\r\n![Canopy app account page](http://i.imgur.com/oetOZW2.png)\r\n\r\n![Canopy app brand page](http://i.imgur.com/9facQ0L.jpg)\r\n\r\nLet’s use the Advanced Custom Fields (ACF) plugin to add the new content types to our Wordpress instance. You will notice that the plugin gives you a lot of options when it comes to choosing a field type or determining its location in the entry editor. The plugin also allows you to add specific validations rules to a field. Work through these to add product, user and brand content types to your website. \r\n\t<a snapshot of a created content type>\r\n\r\nNavigate to the entry editor and you will see the fields you added displayed in the entry editor. \r\n\r\nA note on navigation. Since Wordpress was designed with a static content model in mind, keeping track of all the extra fields you add initially can be a bit unwieldy. You will save yourself a lot of trouble by using ‘location rules’ and ‘hide on screen’ options under the ACF plugin to craft a custom post type displaying only the fields you need. I find that using specific categories to trigger custom layouts works best.\r\n\t<Example highlight a custom layout>\r\n\r\n## Extending the API\r\nThe next important step we have to make is to add custom endpoints to the WP API plugin allowing us to fetch and create posts with product, user or brand information by making API calls. Just as we already did with default posts and authors in the “Working with the API” section. \r\n\r\nBefore we start adding the custom routes, it is important to realize that any custom fields you added with the ACF plugin are automatically exposed when calling a post URL:\r\n\tExample of the fields listed in a default version and with the addition of the custom fields\r\n\r\nIf you plan to work with the default entities via API, I strongly encourage you to spend a few minutes restoring the structure of HTTP responses to its original state. This will give you an improvement in API performance as well as keep the responses easier to read. You can do that by editing the original X.php file. Just unset all the newly added fields after the Y call:\r\n\t<Example of how to suppress custom fields from showing in the API response for a default post.>\r\n\r\n### The basics\r\nAdding custom endpoints is a winding process that requires good knowledge of Wordpress inner workings, so let’s break the code down into specific steps and add some comments to that. We start by writing a simple function that gathers custom fields for a product type:\r\n\t<?php\r\n\t/**\r\n \t* Grab latest post title by an author!\r\n\t *\r\n \t* @param array $data Options for the function.\r\n \t* @return string|null Post title for the latest, \t * or null if none.\r\n \t*/\r\n\tfunction my_awesome_func( $data ) {\r\n  \t  $posts = get_posts( array(\r\n    \t    ‘product’ => $data[‘id’],\r\n    \t) );\r\n  \t  if ( empty( $posts ) ) {\r\n    \t    return null;\r\n    \t}\r\n  \t  return $posts[0]->product_data;\r\n\t}\r\n\r\nTo make this available via the API, we need to register a route. This tells the API to respond to a given request with our function. We do this through a function called ‘register_rest_route’, which should be called in a callback on ‘rest_api_init’. ‘register_rest_route’ function requires three arguments: the namespace, the route we want, and the options. \r\n\t<?php\r\n\tadd_action( ‘rest_api_init’, function () {\r\n  \t  register_rest_route( ‘product/v1’, ‘/product/(?P<id>\\d+)’, \tarray(\r\n  \t      ‘methods’ => ‘GET’,\r\n    \t    ‘callback’ => ‘my_awesome_func’,\r\n    \t) );\r\n\t} );\r\n\r\nJust to clarify, namespaces are the first part of the URL for the endpoint. They should follow the pattern of vendor/v1, where vendor is typically your plugin or theme slug, and v1 represents the first version of the API.\r\n\r\nBy default, routes receive all arguments passed in from the request. These are merged into a single set of parameters, then added to the Request object, which is passed in as the first parameter to your endpoint:\r\n\t<?php\r\n\tfunction my_awesome_func( WP_REST_Request $request ) {\r\n\t    // You can access parameters via direct array access on \tthe object:\r\n\t    $param = $request[‘some_param’];\r\n\t    // Or via the helper method:\r\n\t    $param = $request->get_param( ‘some_param’ );\r\n\t    // You can get the combined, merged set of parameters:\r\n  \t  $parameters = $request->get_params();\r\n\t    // The individual sets of parameters are also available, if needed:\r\n\t    $parameters = $request->get_url_params();\r\n\t    $parameters = $request->get_query_params();\r\n\t    $parameters = $request->get_body_params();\r\n\t    $parameters = $request->get_default_params();\r\n\t    // Uploads aren’t merged in, but can be accessed separately:\r\n\t    $parameters = $request->get_file_params();\r\n\t}\r\n\r\n#### Arguments\r\nArguments are defined as a map in the key args for each endpoint (next to your callback option). This map uses the name of the argument of the key, with the value being a map of options for that argument. This array can contain a key for default, required, sanitize_callback and validate_callback.\r\n\r\n- *default*: Used as the default value for the argument, if none is supplied.\r\n- *required*: If defined as true, and no value is passed for that argument, an error will be returned. No effect if a default value is set, as the argument will always have a value.\r\n- *validate_callback*: Used to pass a function that will be passed the value of the argument. That function should return true if the value is valid, and false if not.\r\n- *sanitize_callback*: Used to pass a function that is used to sanitize the value of the argument before passing it to the main callback.\r\n\r\nUsing sanitize_callback and validate_callback allows the main callback to act only to process the request, and prepare data to be returned using the WP_REST_Response class. By using these two callbacks, you will be able to safely assume your inputs are valid and safe when processing.\r\n\r\nHere is an example of sanitizing the input to ensure that ID provided is a number:\r\n\t<?php\r\n\tadd_action( ‘rest_api_init’, function () {\r\n\t    register_rest_route( ‘myplugin/v1’, ‘/author/(?P<id>\\d+)’, \tarray(\r\n\t        ‘methods’ => ‘GET’,\r\n\t        ‘callback’ => ‘my_awesome_func’,\r\n\t        ‘args’ => array(\r\n  \t          ‘id’ => array(\r\n \t               ‘validate_callback’ => ‘is_numeric’\r\n\t            ),\r\n\t        ),\r\n\t    ) );\r\n\t} );\r\n\r\n#### Return Value\r\nAfter your callback is called, the return value is then converted to JSON, and returned to the client. This allows you to return basically any form of data. In our example above, we’re returning either a string or null, which are automatically handled by the API and converted to JSON.\r\n\r\nLike any other WordPress function, you can also return a WP_Error instance. This error information will be passed along to the client, along with a 500 Internal Service Error status code. You can further customize your error by setting the status option in the WP_Error instance data to a code, such as 400 for bad input data.\r\n\r\n\t<?php\r\n\t/**\r\n \t\t* Grab latest post title by an author!\r\n \t*\r\n\t\t* @param array $data Options for the function.\r\n\t\t* @return string|null Post title for the latest,\r\n\t\t* or null if none.\r\n\t */\r\n\tfunction my_awesome_func( $data ) {\r\n\t    $posts = get_posts( array(\r\n\t        ‘author’ => $data[‘id’],\r\n \t   ) );\r\n\t\r\n\t    if ( empty( $posts ) ) {\r\n\t        return new WP_Error( ‘awesome_no_author’, ‘Invalid \tauthor’, array( ‘status’ => 404 ) );\r\n  \t  }\r\n\t\r\n  \t  return $posts[0]->post_title;\r\n\t}\r\n\r\n#### Permission callback\r\nYou can also register a permissions callback for the endpoint. This is a function that checks if the user can perform the action (reading, updating, etc) before the real callback is called. This allows the API to tell the client what actions they can perform on a given URL without needing to attempt the request first.\r\n\r\n\t<?php\r\n\tadd_action( ‘rest_api_init’, function () {\r\n\t    register_rest_route( ‘myplugin/v1’, ‘/author/(?P<id>\\d+)’, \tarray(\r\n\t        ‘methods’ => ‘GET’,\r\n\t        ‘callback’ => ‘my_awesome_func’,\r\n\t        ‘args’ => array(\r\n\t            ‘id’ => array(\r\n\t                ‘validate_callback’ => ‘is_numeric’\r\n\t            ),\r\n\t        ),\r\n\t        ‘permission_callback’ => function () {\r\n\t            return current_user_can( ‘edit_others_posts’ );\r\n\t        }\r\n\t    ) );\r\n\t} );\r\n\r\nYou can follow a reference code for adding a custom ‘product’ route on [Gist][13]. You have to repeat the same step to extend the custom route with additional endpoints for POST, PUT and DELETE actions. And then repeat the process for the remaining two content types. At the end of this exercise, you should have a custom API enabling you to manage the content of the app directly from Wordpress.    \r\n\r\n## Parting thoughts\r\nIf you have successfully arrived at this point, you now can enjoy a user-friendly interface to manage the content on your mobile app. I am also certain that the time necessary to get this solution app and running is significantly shorter than the alternative of building it from the scratch. \r\n\r\nFor those of you who are not familiar with Wordpress platform, I admit that some steps - especially extending the API - can be challenging. The fact that many plugin developers fail to provide comprehensive, up-to-date documentation or maintain compatibility with the older versions of the platform just adds up to the frustration. If you find yourself in this situation, I suggest you look at purpose-built mobile backends.\r\n\r\nThe three names that get a lot of mentions are [Parse][14], [Contentful][15] and [Prismic][16]. I have used the latter two for my hobby projects and found the initial setup and customization did not require any major coding skills. So if your PHP skills are rusty, these tools offer a good alternative. \r\n\r\nHope the tutorial was useful for you. If you notice any inconsistencies or spot useful tools facilitating the process, let me know and I would be happy to update the post.\r\n\r\n## Useful links\r\nLinks below point to more detailed resources on the relevant topics: \r\nhttps://aaronparecki.com/articles/2012/07/29/1/oauth2-simplified \r\nhttp://hasin.me/2015/07/18/using-oauth2-to-make-authenticated-calls-to-wp-rest-api/ \r\nhttps://deliciousbrains.com/creating-mobile-app-wp-api-react-native/\r\nhttps://zapier.com/learn/apis/ \r\n\r\n[1]: https://itunes.apple.com/us/app/canopy-curated-shop-for-amazon/id927695605?mt=8\r\n[2]: https://cyberduck.io/\r\n[3]: https://filezilla-project.org/\r\n[4]: http://www.panic.com/transmit/\r\n[5]: http://wp-api.org/\r\n[6]: http://www.advancedcustomfields.com/add-ons/flexible-content-field/\r\n[7]: https://wp-oauth.com/\r\n[8]: https://wordpress.org/plugins/wp-basic-auth/\r\n[9]: http://wp-api.org/guides/authentication.html\r\n[10]: https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en\r\n[11]: https://chrome.google.com/webstore/detail/dhc-resthttp-api-client/aejoelaoggembcahagimdiliamlcdmfm?hl=en\r\n[12]: http://stedolan.github.io/jq/\r\n[13]: GIST repo for the code\r\n[14]: https://www.parse.com/\r\n[15]: https://www.contentful.com/\r\n[16]: https://prismic.io/","google":"UA-68707966-1","note":"Don't delete this file! It's used internally to help with page regeneration."}